/* DO NOT EDIT: automatically built by dist/s_prototypes. */

extern void __ae_async_stats_update(AE_SESSION_IMPL *session);
extern int __ae_async_create(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_async_reconfig(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_async_destroy(AE_SESSION_IMPL *session);
extern int __ae_async_flush(AE_SESSION_IMPL *session);
extern int __ae_async_new_op(AE_SESSION_IMPL *session, const char *uri, const char *config, const char *cfg[], AE_ASYNC_CALLBACK *cb, AE_ASYNC_OP_IMPL **opp);
extern int __ae_async_op_enqueue(AE_SESSION_IMPL *session, AE_ASYNC_OP_IMPL *op);
extern int __ae_async_op_init(AE_SESSION_IMPL *session);
extern AE_THREAD_RET __ae_async_worker(void *arg);
extern int __ae_block_addr_to_buffer(AE_BLOCK *block, uint8_t **pp, ae_off_t offset, uint32_t size, uint32_t cksum);
extern int __ae_block_buffer_to_addr(AE_BLOCK *block, const uint8_t *p, ae_off_t *offsetp, uint32_t *sizep, uint32_t *cksump);
extern int __ae_block_addr_invalid(AE_SESSION_IMPL *session, AE_BLOCK *block, const uint8_t *addr, size_t addr_size, bool live);
extern int __ae_block_addr_string(AE_SESSION_IMPL *session, AE_BLOCK *block, AE_ITEM *buf, const uint8_t *addr, size_t addr_size);
extern int __ae_block_buffer_to_ckpt(AE_SESSION_IMPL *session, AE_BLOCK *block, const uint8_t *p, AE_BLOCK_CKPT *ci);
extern int __ae_block_ckpt_to_buffer(AE_SESSION_IMPL *session, AE_BLOCK *block, uint8_t **pp, AE_BLOCK_CKPT *ci);
extern int __ae_block_ckpt_init( AE_SESSION_IMPL *session, AE_BLOCK_CKPT *ci, const char *name);
extern int __ae_block_checkpoint_load(AE_SESSION_IMPL *session, AE_BLOCK *block, const uint8_t *addr, size_t addr_size, uint8_t *root_addr, size_t *root_addr_sizep, bool checkpoint);
extern int __ae_block_checkpoint_unload( AE_SESSION_IMPL *session, AE_BLOCK *block, bool checkpoint);
extern void __ae_block_ckpt_destroy(AE_SESSION_IMPL *session, AE_BLOCK_CKPT *ci);
extern int __ae_block_checkpoint(AE_SESSION_IMPL *session, AE_BLOCK *block, AE_ITEM *buf, AE_CKPT *ckptbase, bool data_cksum);
extern int __ae_block_checkpoint_resolve(AE_SESSION_IMPL *session, AE_BLOCK *block);
extern int __ae_block_compact_start(AE_SESSION_IMPL *session, AE_BLOCK *block);
extern int __ae_block_compact_end(AE_SESSION_IMPL *session, AE_BLOCK *block);
extern int __ae_block_compact_skip(AE_SESSION_IMPL *session, AE_BLOCK *block, bool *skipp);
extern int __ae_block_compact_page_skip(AE_SESSION_IMPL *session, AE_BLOCK *block, const uint8_t *addr, size_t addr_size, bool *skipp);
extern int __ae_block_misplaced(AE_SESSION_IMPL *session, AE_BLOCK *block, const char *tag, ae_off_t offset, uint32_t size, bool live);
extern int __ae_block_off_remove_overlap(AE_SESSION_IMPL *session, AE_BLOCK *block, AE_EXTLIST *el, ae_off_t off, ae_off_t size);
extern int __ae_block_alloc( AE_SESSION_IMPL *session, AE_BLOCK *block, ae_off_t *offp, ae_off_t size);
extern int __ae_block_free(AE_SESSION_IMPL *session, AE_BLOCK *block, const uint8_t *addr, size_t addr_size);
extern int __ae_block_off_free( AE_SESSION_IMPL *session, AE_BLOCK *block, ae_off_t offset, ae_off_t size);
extern int __ae_block_extlist_check( AE_SESSION_IMPL *session, AE_EXTLIST *al, AE_EXTLIST *bl);
extern int __ae_block_extlist_overlap( AE_SESSION_IMPL *session, AE_BLOCK *block, AE_BLOCK_CKPT *ci);
extern int __ae_block_extlist_merge(AE_SESSION_IMPL *session, AE_BLOCK *block, AE_EXTLIST *a, AE_EXTLIST *b);
extern int __ae_block_insert_ext(AE_SESSION_IMPL *session, AE_BLOCK *block, AE_EXTLIST *el, ae_off_t off, ae_off_t size);
extern int __ae_block_extlist_read_avail(AE_SESSION_IMPL *session, AE_BLOCK *block, AE_EXTLIST *el, ae_off_t ckpt_size);
extern int __ae_block_extlist_read(AE_SESSION_IMPL *session, AE_BLOCK *block, AE_EXTLIST *el, ae_off_t ckpt_size);
extern int __ae_block_extlist_write(AE_SESSION_IMPL *session, AE_BLOCK *block, AE_EXTLIST *el, AE_EXTLIST *additional);
extern int __ae_block_extlist_truncate( AE_SESSION_IMPL *session, AE_BLOCK *block, AE_EXTLIST *el);
extern int __ae_block_extlist_init(AE_SESSION_IMPL *session, AE_EXTLIST *el, const char *name, const char *extname, bool track_size);
extern void __ae_block_extlist_free(AE_SESSION_IMPL *session, AE_EXTLIST *el);
extern int __ae_block_map( AE_SESSION_IMPL *session, AE_BLOCK *block, void *mapp, size_t *maplenp, void **mappingcookie);
extern int __ae_block_unmap( AE_SESSION_IMPL *session, AE_BLOCK *block, void *map, size_t maplen, void **mappingcookie);
extern int __ae_block_manager_open(AE_SESSION_IMPL *session, const char *filename, const char *cfg[], bool forced_salvage, bool readonly, uint32_t allocsize, AE_BM **bmp);
extern int __ae_block_manager_truncate( AE_SESSION_IMPL *session, const char *filename, uint32_t allocsize);
extern int __ae_block_manager_create( AE_SESSION_IMPL *session, const char *filename, uint32_t allocsize);
extern void __ae_block_configure_first_fit(AE_BLOCK *block, bool on);
extern int __ae_block_open(AE_SESSION_IMPL *session, const char *filename, const char *cfg[], bool forced_salvage, bool readonly, uint32_t allocsize, AE_BLOCK **blockp);
extern int __ae_block_close(AE_SESSION_IMPL *session, AE_BLOCK *block);
extern int __ae_desc_init(AE_SESSION_IMPL *session, AE_FH *fh, uint32_t allocsize);
extern void __ae_block_stat(AE_SESSION_IMPL *session, AE_BLOCK *block, AE_DSRC_STATS *stats);
extern int __ae_block_manager_size( AE_SESSION_IMPL *session, const char *filename, AE_DSRC_STATS *stats);
extern int __ae_bm_preload(AE_BM *bm, AE_SESSION_IMPL *session, const uint8_t *addr, size_t addr_size);
extern int __ae_bm_read(AE_BM *bm, AE_SESSION_IMPL *session, AE_ITEM *buf, const uint8_t *addr, size_t addr_size);
extern int __ae_block_read_off_blind( AE_SESSION_IMPL *session, AE_BLOCK *block, AE_ITEM *buf, ae_off_t offset);
extern int __ae_block_read_off(AE_SESSION_IMPL *session, AE_BLOCK *block, AE_ITEM *buf, ae_off_t offset, uint32_t size, uint32_t cksum);
extern int __ae_block_ext_alloc(AE_SESSION_IMPL *session, AE_EXT **extp);
extern void __ae_block_ext_free(AE_SESSION_IMPL *session, AE_EXT *ext);
extern int __ae_block_size_alloc(AE_SESSION_IMPL *session, AE_SIZE **szp);
extern void __ae_block_size_free(AE_SESSION_IMPL *session, AE_SIZE *sz);
extern int __ae_block_ext_prealloc(AE_SESSION_IMPL *session, u_int max);
extern int __ae_block_ext_discard(AE_SESSION_IMPL *session, u_int max);
extern int __ae_block_salvage_start(AE_SESSION_IMPL *session, AE_BLOCK *block);
extern int __ae_block_salvage_end(AE_SESSION_IMPL *session, AE_BLOCK *block);
extern bool __ae_block_offset_invalid(AE_BLOCK *block, ae_off_t offset, uint32_t size);
extern int __ae_block_salvage_next(AE_SESSION_IMPL *session, AE_BLOCK *block, uint8_t *addr, size_t *addr_sizep, bool *eofp);
extern int __ae_block_salvage_valid(AE_SESSION_IMPL *session, AE_BLOCK *block, uint8_t *addr, size_t addr_size, bool valid);
extern int __ae_block_verify_start(AE_SESSION_IMPL *session, AE_BLOCK *block, AE_CKPT *ckptbase, const char *cfg[]);
extern int __ae_block_verify_end(AE_SESSION_IMPL *session, AE_BLOCK *block);
extern int __ae_verify_ckpt_load( AE_SESSION_IMPL *session, AE_BLOCK *block, AE_BLOCK_CKPT *ci);
extern int __ae_verify_ckpt_unload(AE_SESSION_IMPL *session, AE_BLOCK *block);
extern int __ae_block_verify_addr(AE_SESSION_IMPL *session, AE_BLOCK *block, const uint8_t *addr, size_t addr_size);
extern u_int __ae_block_header(AE_BLOCK *block);
extern int __ae_block_truncate(AE_SESSION_IMPL *session, AE_FH *fh, ae_off_t len);
extern int __ae_block_write_size(AE_SESSION_IMPL *session, AE_BLOCK *block, size_t *sizep);
extern int __ae_block_write(AE_SESSION_IMPL *session, AE_BLOCK *block, AE_ITEM *buf, uint8_t *addr, size_t *addr_sizep, bool data_cksum);
extern int __ae_block_write_off(AE_SESSION_IMPL *session, AE_BLOCK *block, AE_ITEM *buf, ae_off_t *offsetp, uint32_t *sizep, uint32_t *cksump, bool data_cksum, bool caller_locked);
extern int __ae_bloom_create( AE_SESSION_IMPL *session, const char *uri, const char *config, uint64_t count, uint32_t factor, uint32_t k, AE_BLOOM **bloomp);
extern int __ae_bloom_open(AE_SESSION_IMPL *session, const char *uri, uint32_t factor, uint32_t k, AE_CURSOR *owner, AE_BLOOM **bloomp);
extern int __ae_bloom_insert(AE_BLOOM *bloom, AE_ITEM *key);
extern int __ae_bloom_finalize(AE_BLOOM *bloom);
extern int __ae_bloom_hash(AE_BLOOM *bloom, AE_ITEM *key, AE_BLOOM_HASH *bhash);
extern int __ae_bloom_hash_get(AE_BLOOM *bloom, AE_BLOOM_HASH *bhash);
extern int __ae_bloom_get(AE_BLOOM *bloom, AE_ITEM *key);
extern int __ae_bloom_inmem_get(AE_BLOOM *bloom, AE_ITEM *key);
extern int __ae_bloom_intersection(AE_BLOOM *bloom, AE_BLOOM *other);
extern int __ae_bloom_close(AE_BLOOM *bloom);
extern int __ae_bloom_drop(AE_BLOOM *bloom, const char *config);
extern int __ae_compact(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_compact_page_skip(AE_SESSION_IMPL *session, AE_REF *ref, bool *skipp);
extern void __ae_btcur_iterate_setup(AE_CURSOR_BTREE *cbt);
extern int __ae_btcur_next(AE_CURSOR_BTREE *cbt, bool truncating);
extern int __ae_btcur_prev(AE_CURSOR_BTREE *cbt, bool truncating);
extern int __ae_btcur_reset(AE_CURSOR_BTREE *cbt);
extern int __ae_btcur_search(AE_CURSOR_BTREE *cbt);
extern int __ae_btcur_search_near(AE_CURSOR_BTREE *cbt, int *exactp);
extern int __ae_btcur_insert(AE_CURSOR_BTREE *cbt);
extern int __ae_btcur_update_check(AE_CURSOR_BTREE *cbt);
extern int __ae_btcur_remove(AE_CURSOR_BTREE *cbt);
extern int __ae_btcur_update(AE_CURSOR_BTREE *cbt);
extern int __ae_btcur_next_random(AE_CURSOR_BTREE *cbt);
extern int __ae_btcur_compare(AE_CURSOR_BTREE *a_arg, AE_CURSOR_BTREE *b_arg, int *cmpp);
extern int __ae_btcur_equals(AE_CURSOR_BTREE *a_arg, AE_CURSOR_BTREE *b_arg, int *equalp);
extern int __ae_btcur_range_truncate(AE_CURSOR_BTREE *start, AE_CURSOR_BTREE *stop);
extern void __ae_btcur_init(AE_SESSION_IMPL *session, AE_CURSOR_BTREE *cbt);
extern void __ae_btcur_open(AE_CURSOR_BTREE *cbt);
extern int __ae_btcur_close(AE_CURSOR_BTREE *cbt, bool lowlevel);
extern int __ae_debug_set_verbose(AE_SESSION_IMPL *session, const char *v);
extern int __ae_debug_addr_print( AE_SESSION_IMPL *session, const uint8_t *addr, size_t addr_size);
extern int __ae_debug_addr(AE_SESSION_IMPL *session, const uint8_t *addr, size_t addr_size, const char *ofile);
extern int __ae_debug_offset_blind( AE_SESSION_IMPL *session, ae_off_t offset, const char *ofile);
extern int __ae_debug_offset(AE_SESSION_IMPL *session, ae_off_t offset, uint32_t size, uint32_t cksum, const char *ofile);
extern int __ae_debug_disk( AE_SESSION_IMPL *session, const AE_PAGE_HEADER *dsk, const char *ofile);
extern int __ae_debug_tree_shape( AE_SESSION_IMPL *session, AE_PAGE *page, const char *ofile);
extern int __ae_debug_tree_all( AE_SESSION_IMPL *session, AE_BTREE *btree, AE_PAGE *page, const char *ofile);
extern int __ae_debug_tree( AE_SESSION_IMPL *session, AE_BTREE *btree, AE_PAGE *page, const char *ofile);
extern int __ae_debug_page(AE_SESSION_IMPL *session, AE_PAGE *page, const char *ofile);
extern int __ae_delete_page(AE_SESSION_IMPL *session, AE_REF *ref, bool *skipp);
extern void __ae_delete_page_rollback(AE_SESSION_IMPL *session, AE_REF *ref);
extern bool __ae_delete_page_skip(AE_SESSION_IMPL *session, AE_REF *ref, bool visible_all);
extern int __ae_delete_page_instantiate(AE_SESSION_IMPL *session, AE_REF *ref);
extern void __ae_ref_out(AE_SESSION_IMPL *session, AE_REF *ref);
extern void __ae_page_out(AE_SESSION_IMPL *session, AE_PAGE **pagep);
extern void __ae_free_ref( AE_SESSION_IMPL *session, AE_REF *ref, int page_type, bool free_pages);
extern void __ae_free_ref_index(AE_SESSION_IMPL *session, AE_PAGE *page, AE_PAGE_INDEX *pindex, bool free_pages);
extern void __ae_free_update_list(AE_SESSION_IMPL *session, AE_UPDATE *upd);
extern int __ae_btree_open(AE_SESSION_IMPL *session, const char *op_cfg[]);
extern int __ae_btree_close(AE_SESSION_IMPL *session);
extern void __ae_root_ref_init(AE_REF *root_ref, AE_PAGE *root, bool is_recno);
extern int __ae_btree_tree_open( AE_SESSION_IMPL *session, const uint8_t *addr, size_t addr_size);
extern int __ae_btree_new_leaf_page(AE_SESSION_IMPL *session, AE_PAGE **pagep);
extern void __ae_btree_evictable(AE_SESSION_IMPL *session, bool on);
extern int __ae_btree_huffman_open(AE_SESSION_IMPL *session);
extern void __ae_btree_huffman_close(AE_SESSION_IMPL *session);
extern int __ae_bt_read(AE_SESSION_IMPL *session, AE_ITEM *buf, const uint8_t *addr, size_t addr_size);
extern int __ae_bt_write(AE_SESSION_IMPL *session, AE_ITEM *buf, uint8_t *addr, size_t *addr_sizep, bool checkpoint, bool compressed);
extern const char *__ae_page_type_string(u_int type);
extern const char *__ae_cell_type_string(uint8_t type);
extern const char *__ae_page_addr_string(AE_SESSION_IMPL *session, AE_REF *ref, AE_ITEM *buf);
extern const char *__ae_addr_string(AE_SESSION_IMPL *session, const uint8_t *addr, size_t addr_size, AE_ITEM *buf);
extern int __ae_ovfl_read(AE_SESSION_IMPL *session, AE_PAGE *page, AE_CELL_UNPACK *unpack, AE_ITEM *store);
extern int __ae_ovfl_cache(AE_SESSION_IMPL *session, AE_PAGE *page, void *cookie, AE_CELL_UNPACK *vpack);
extern int __ae_ovfl_discard(AE_SESSION_IMPL *session, AE_CELL *cell);
extern int __ae_page_alloc(AE_SESSION_IMPL *session, uint8_t type, uint64_t recno, uint32_t alloc_entries, bool alloc_refs, AE_PAGE **pagep);
extern int __ae_page_inmem(AE_SESSION_IMPL *session, AE_REF *ref, const void *image, size_t memsize, uint32_t flags, AE_PAGE **pagep);
extern int __ae_las_remove_block(AE_SESSION_IMPL *session, AE_CURSOR *cursor, uint32_t btree_id, const uint8_t *addr, size_t addr_size);
extern int
__ae_page_in_func(AE_SESSION_IMPL *session, AE_REF *ref, uint32_t flags
#ifdef HAVE_DIAGNOSTIC
 , const char *file, int line
#endif
 );
extern int __ae_kv_return(AE_SESSION_IMPL *session, AE_CURSOR_BTREE *cbt, AE_UPDATE *upd);
extern int __ae_bt_salvage(AE_SESSION_IMPL *session, AE_CKPT *ckptbase, const char *cfg[]);
extern void __ae_split_stash_discard(AE_SESSION_IMPL *session);
extern void __ae_split_stash_discard_all( AE_SESSION_IMPL *session_safe, AE_SESSION_IMPL *session);
extern int __ae_multi_to_ref(AE_SESSION_IMPL *session, AE_PAGE *page, AE_MULTI *multi, AE_REF **refp, size_t *incrp);
extern int __ae_split_insert(AE_SESSION_IMPL *session, AE_REF *ref);
extern int __ae_split_multi(AE_SESSION_IMPL *session, AE_REF *ref, int closing);
extern int __ae_split_reverse(AE_SESSION_IMPL *session, AE_REF *ref);
extern int __ae_split_rewrite(AE_SESSION_IMPL *session, AE_REF *ref);
extern int __ae_btree_stat_init(AE_SESSION_IMPL *session, AE_CURSOR_STAT *cst);
extern int __ae_cache_op(AE_SESSION_IMPL *session, AE_CKPT *ckptbase, AE_CACHE_OP op);
extern int __ae_upgrade(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_verify(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_verify_dsk_image(AE_SESSION_IMPL *session, const char *tag, const AE_PAGE_HEADER *dsk, size_t size, bool empty_page_ok);
extern int __ae_verify_dsk(AE_SESSION_IMPL *session, const char *tag, AE_ITEM *buf);
extern int __ae_tree_walk(AE_SESSION_IMPL *session, AE_REF **refp, uint64_t *walkcntp, uint32_t flags);
extern int __ae_col_modify(AE_SESSION_IMPL *session, AE_CURSOR_BTREE *cbt, uint64_t recno, AE_ITEM *value, AE_UPDATE *upd_arg, bool is_remove);
extern int __ae_col_search(AE_SESSION_IMPL *session, uint64_t recno, AE_REF *leaf, AE_CURSOR_BTREE *cbt);
extern int __ae_row_leaf_keys(AE_SESSION_IMPL *session, AE_PAGE *page);
extern int __ae_row_leaf_key_copy( AE_SESSION_IMPL *session, AE_PAGE *page, AE_ROW *rip, AE_ITEM *key);
extern int __ae_row_leaf_key_work(AE_SESSION_IMPL *session, AE_PAGE *page, AE_ROW *rip_arg, AE_ITEM *keyb, bool instantiate);
extern int __ae_row_ikey_alloc(AE_SESSION_IMPL *session, uint32_t cell_offset, const void *key, size_t size, AE_IKEY **ikeyp);
extern int __ae_row_ikey_incr(AE_SESSION_IMPL *session, AE_PAGE *page, uint32_t cell_offset, const void *key, size_t size, AE_REF *ref);
extern int __ae_row_ikey(AE_SESSION_IMPL *session, uint32_t cell_offset, const void *key, size_t size, AE_REF *ref);
extern int __ae_page_modify_alloc(AE_SESSION_IMPL *session, AE_PAGE *page);
extern int __ae_row_modify(AE_SESSION_IMPL *session, AE_CURSOR_BTREE *cbt, AE_ITEM *key, AE_ITEM *value, AE_UPDATE *upd_arg, bool is_remove);
extern int __ae_row_insert_alloc(AE_SESSION_IMPL *session, AE_ITEM *key, u_int skipdepth, AE_INSERT **insp, size_t *ins_sizep);
extern int __ae_update_alloc( AE_SESSION_IMPL *session, AE_ITEM *value, AE_UPDATE **updp, size_t *sizep);
extern AE_UPDATE *__ae_update_obsolete_check( AE_SESSION_IMPL *session, AE_PAGE *page, AE_UPDATE *upd);
extern void __ae_update_obsolete_free( AE_SESSION_IMPL *session, AE_PAGE *page, AE_UPDATE *upd);
extern int __ae_search_insert( AE_SESSION_IMPL *session, AE_CURSOR_BTREE *cbt, AE_ITEM *srch_key);
extern int __ae_row_search(AE_SESSION_IMPL *session, AE_ITEM *srch_key, AE_REF *leaf, AE_CURSOR_BTREE *cbt, bool insert);
extern int __ae_row_random(AE_SESSION_IMPL *session, AE_CURSOR_BTREE *cbt);
extern void __ae_las_stats_update(AE_SESSION_IMPL *session);
extern int __ae_las_create(AE_SESSION_IMPL *session);
extern int __ae_las_destroy(AE_SESSION_IMPL *session);
extern void __ae_las_set_written(AE_SESSION_IMPL *session);
extern bool __ae_las_is_written(AE_SESSION_IMPL *session);
extern int __ae_las_cursor_create(AE_SESSION_IMPL *session, AE_CURSOR **cursorp);
extern int __ae_las_cursor( AE_SESSION_IMPL *session, AE_CURSOR **cursorp, uint32_t *session_flags);
extern int __ae_las_cursor_close( 	AE_SESSION_IMPL *session, AE_CURSOR **cursorp, uint32_t session_flags);
extern int __ae_las_sweep(AE_SESSION_IMPL *session);
extern int __ae_config_initn( AE_SESSION_IMPL *session, AE_CONFIG *conf, const char *str, size_t len);
extern int __ae_config_init(AE_SESSION_IMPL *session, AE_CONFIG *conf, const char *str);
extern int __ae_config_subinit( AE_SESSION_IMPL *session, AE_CONFIG *conf, AE_CONFIG_ITEM *item);
extern int __ae_config_next(AE_CONFIG *conf, AE_CONFIG_ITEM *key, AE_CONFIG_ITEM *value);
extern int __ae_config_get(AE_SESSION_IMPL *session, const char **cfg_arg, AE_CONFIG_ITEM *key, AE_CONFIG_ITEM *value);
extern int __ae_config_gets(AE_SESSION_IMPL *session, const char **cfg, const char *key, AE_CONFIG_ITEM *value);
extern int __ae_config_gets_none(AE_SESSION_IMPL *session, const char **cfg, const char *key, AE_CONFIG_ITEM *value);
extern int __ae_config_getone(AE_SESSION_IMPL *session, const char *config, AE_CONFIG_ITEM *key, AE_CONFIG_ITEM *value);
extern int __ae_config_getones(AE_SESSION_IMPL *session, const char *config, const char *key, AE_CONFIG_ITEM *value);
extern int __ae_config_getones_none(AE_SESSION_IMPL *session, const char *config, const char *key, AE_CONFIG_ITEM *value);
extern int __ae_config_gets_def(AE_SESSION_IMPL *session, const char **cfg, const char *key, int def, AE_CONFIG_ITEM *value);
extern int __ae_config_subgetraw(AE_SESSION_IMPL *session, AE_CONFIG_ITEM *cfg, AE_CONFIG_ITEM *key, AE_CONFIG_ITEM *value);
extern int __ae_config_subgets(AE_SESSION_IMPL *session, AE_CONFIG_ITEM *cfg, const char *key, AE_CONFIG_ITEM *value);
extern void __ae_conn_foc_discard(AE_SESSION_IMPL *session);
extern int __ae_configure_method(AE_SESSION_IMPL *session, const char *method, const char *uri, const char *config, const char *type, const char *check);
extern int __ae_config_check(AE_SESSION_IMPL *session, const AE_CONFIG_ENTRY *entry, const char *config, size_t config_len);
extern int __ae_config_collapse( AE_SESSION_IMPL *session, const char **cfg, char **config_ret);
extern int __ae_config_merge(AE_SESSION_IMPL *session, const char **cfg, const char *cfg_strip, const char **config_ret);
extern int __ae_conn_config_init(AE_SESSION_IMPL *session);
extern void __ae_conn_config_discard(AE_SESSION_IMPL *session);
extern const AE_CONFIG_ENTRY *__ae_conn_config_match(const char *method);
extern int __ae_ext_config_parser_open(AE_EXTENSION_API *ae_ext, AE_SESSION *ae_session, const char *config, size_t len, AE_CONFIG_PARSER **config_parserp);
extern int __ae_ext_config_get(AE_EXTENSION_API *ae_api, AE_SESSION *ae_session, AE_CONFIG_ARG *cfg_arg, const char *key, AE_CONFIG_ITEM *cval);
extern int __ae_config_upgrade(AE_SESSION_IMPL *session, AE_ITEM *buf);
extern const char *__ae_archengine_error(int error);
extern int __ae_collator_config(AE_SESSION_IMPL *session, const char *uri, AE_CONFIG_ITEM *cname, AE_CONFIG_ITEM *metadata, AE_COLLATOR **collatorp, int *ownp);
extern int __ae_conn_remove_collator(AE_SESSION_IMPL *session);
extern int __ae_compressor_config( AE_SESSION_IMPL *session, AE_CONFIG_ITEM *cval, AE_COMPRESSOR **compressorp);
extern int __ae_conn_remove_compressor(AE_SESSION_IMPL *session);
extern int __ae_conn_remove_data_source(AE_SESSION_IMPL *session);
extern int __ae_encryptor_config(AE_SESSION_IMPL *session, AE_CONFIG_ITEM *cval, AE_CONFIG_ITEM *keyid, AE_CONFIG_ARG *cfg_arg, AE_KEYED_ENCRYPTOR **kencryptorp);
extern int __ae_conn_remove_encryptor(AE_SESSION_IMPL *session);
extern int __ae_extractor_config(AE_SESSION_IMPL *session, const char *uri, const char *config, AE_EXTRACTOR **extractorp, int *ownp);
extern int __ae_conn_remove_extractor(AE_SESSION_IMPL *session);
extern int __ae_verbose_config(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_cache_config(AE_SESSION_IMPL *session, bool reconfigure, const char *cfg[]);
extern int __ae_cache_create(AE_SESSION_IMPL *session, const char *cfg[]);
extern void __ae_cache_stats_update(AE_SESSION_IMPL *session);
extern int __ae_cache_destroy(AE_SESSION_IMPL *session);
extern int __ae_cache_pool_config(AE_SESSION_IMPL *session, const char **cfg);
extern int __ae_conn_cache_pool_open(AE_SESSION_IMPL *session);
extern int __ae_conn_cache_pool_destroy(AE_SESSION_IMPL *session);
extern AE_THREAD_RET __ae_cache_pool_server(void *arg);
extern int __ae_checkpoint_server_create(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_checkpoint_server_destroy(AE_SESSION_IMPL *session);
extern int __ae_checkpoint_signal(AE_SESSION_IMPL *session, ae_off_t logsize);
extern int __ae_conn_dhandle_find( AE_SESSION_IMPL *session, const char *uri, const char *checkpoint);
extern int __ae_conn_btree_sync_and_close(AE_SESSION_IMPL *session, bool final, bool force);
extern int __ae_conn_btree_open( AE_SESSION_IMPL *session, const char *cfg[], uint32_t flags);
extern int __ae_conn_btree_apply(AE_SESSION_IMPL *session, bool apply_checkpoints, const char *uri, int (*func)(AE_SESSION_IMPL *, const char *[]), const char *cfg[]);
extern int __ae_conn_btree_apply_single_ckpt(AE_SESSION_IMPL *session, const char *uri, int (*func)(AE_SESSION_IMPL *, const char *[]), const char *cfg[]);
extern int __ae_conn_btree_apply_single(AE_SESSION_IMPL *session, const char *uri, const char *checkpoint, int (*func)(AE_SESSION_IMPL *, const char *[]), const char *cfg[]);
extern int __ae_conn_dhandle_close_all( AE_SESSION_IMPL *session, const char *uri, bool force);
extern int __ae_conn_dhandle_discard_single( AE_SESSION_IMPL *session, bool final, bool force);
extern int __ae_conn_dhandle_discard(AE_SESSION_IMPL *session);
extern int __ae_connection_init(AE_CONNECTION_IMPL *conn);
extern int __ae_connection_destroy(AE_CONNECTION_IMPL *conn);
extern int __ae_logmgr_reconfig(AE_SESSION_IMPL *session, const char **cfg);
extern int __ae_log_truncate_files( AE_SESSION_IMPL *session, AE_CURSOR *cursor, const char *cfg[]);
extern int __ae_log_wrlsn(AE_SESSION_IMPL *session);
extern int __ae_logmgr_create(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_logmgr_open(AE_SESSION_IMPL *session);
extern int __ae_logmgr_destroy(AE_SESSION_IMPL *session);
extern int __ae_connection_open(AE_CONNECTION_IMPL *conn, const char *cfg[]);
extern int __ae_connection_close(AE_CONNECTION_IMPL *conn);
extern int __ae_connection_workers(AE_SESSION_IMPL *session, const char *cfg[]);
extern void __ae_conn_stat_init(AE_SESSION_IMPL *session);
extern int __ae_statlog_log_one(AE_SESSION_IMPL *session);
extern int __ae_statlog_create(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_statlog_destroy(AE_SESSION_IMPL *session, bool is_close);
extern int __ae_sweep_config(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_sweep_create(AE_SESSION_IMPL *session);
extern int __ae_sweep_destroy(AE_SESSION_IMPL *session);
extern int __ae_curbackup_open(AE_SESSION_IMPL *session, const char *uri, const char *cfg[], AE_CURSOR **cursorp);
extern int __ae_backup_file_remove(AE_SESSION_IMPL *session);
extern int __ae_backup_list_uri_append( AE_SESSION_IMPL *session, const char *name, bool *skip);
extern int __ae_curbulk_init(AE_SESSION_IMPL *session, AE_CURSOR_BULK *cbulk, bool bitmap, bool skip_sort_check);
extern int __ae_curconfig_open(AE_SESSION_IMPL *session, const char *uri, const char *cfg[], AE_CURSOR **cursorp);
extern int __ae_curds_open( AE_SESSION_IMPL *session, const char *uri, AE_CURSOR *owner, const char *cfg[], AE_DATA_SOURCE *dsrc, AE_CURSOR **cursorp);
extern int __ae_curdump_create(AE_CURSOR *child, AE_CURSOR *owner, AE_CURSOR **cursorp);
extern int __ae_curfile_update_check(AE_CURSOR *cursor);
extern int __ae_curfile_create(AE_SESSION_IMPL *session, AE_CURSOR *owner, const char *cfg[], bool bulk, bool bitmap, AE_CURSOR **cursorp);
extern int __ae_curfile_open(AE_SESSION_IMPL *session, const char *uri, AE_CURSOR *owner, const char *cfg[], AE_CURSOR **cursorp);
extern int __ae_curindex_joined(AE_CURSOR *cursor);
extern int __ae_curindex_open(AE_SESSION_IMPL *session, const char *uri, AE_CURSOR *owner, const char *cfg[], AE_CURSOR **cursorp);
extern int __ae_curjoin_open(AE_SESSION_IMPL *session, const char *uri, AE_CURSOR *owner, const char *cfg[], AE_CURSOR **cursorp);
extern int __ae_curjoin_join(AE_SESSION_IMPL *session, AE_CURSOR_JOIN *cjoin, AE_INDEX *idx, AE_CURSOR *ref_cursor, uint8_t flags, uint8_t range, uint64_t count, uint32_t bloom_bit_count, uint32_t bloom_hash_count);
extern int __ae_json_alloc_unpack(AE_SESSION_IMPL *session, const void *buffer, size_t size, const char *fmt, AE_CURSOR_JSON *json, bool iskey, va_list ap);
extern void __ae_json_close(AE_SESSION_IMPL *session, AE_CURSOR *cursor);
extern size_t __ae_json_unpack_char(char ch, u_char *buf, size_t bufsz, bool force_unicode);
extern int __ae_json_column_init(AE_CURSOR *cursor, const char *keyformat, const AE_CONFIG_ITEM *idxconf, const AE_CONFIG_ITEM *colconf);
extern int __ae_json_token(AE_SESSION *ae_session, const char *src, int *toktype, const char **tokstart, size_t *toklen);
extern const char *__ae_json_tokname(int toktype);
extern int __ae_json_to_item(AE_SESSION_IMPL *session, const char *jstr, const char *format, AE_CURSOR_JSON *json, bool iskey, AE_ITEM *item);
extern ssize_t __ae_json_strlen(const char *src, size_t srclen);
extern int __ae_json_strncpy(char **pdst, size_t dstlen, const char *src, size_t srclen);
extern int __ae_curlog_open(AE_SESSION_IMPL *session, const char *uri, const char *cfg[], AE_CURSOR **cursorp);
extern int __ae_curmetadata_open(AE_SESSION_IMPL *session, const char *uri, AE_CURSOR *owner, const char *cfg[], AE_CURSOR **cursorp);
extern void __ae_curstat_dsrc_final(AE_CURSOR_STAT *cst);
extern int __ae_curstat_init(AE_SESSION_IMPL *session, const char *uri, AE_CURSOR *curjoin, const char *cfg[], AE_CURSOR_STAT *cst);
extern int __ae_curstat_open(AE_SESSION_IMPL *session, const char *uri, AE_CURSOR *other, const char *cfg[], AE_CURSOR **cursorp);
extern int __ae_cursor_notsup(AE_CURSOR *cursor);
extern int __ae_cursor_noop(AE_CURSOR *cursor);
extern void __ae_cursor_set_notsup(AE_CURSOR *cursor);
extern int __ae_cursor_kv_not_set(AE_CURSOR *cursor, bool key);
extern int __ae_cursor_get_key(AE_CURSOR *cursor, ...);
extern void __ae_cursor_set_key(AE_CURSOR *cursor, ...);
extern int __ae_cursor_get_raw_key(AE_CURSOR *cursor, AE_ITEM *key);
extern void __ae_cursor_set_raw_key(AE_CURSOR *cursor, AE_ITEM *key);
extern int __ae_cursor_get_raw_value(AE_CURSOR *cursor, AE_ITEM *value);
extern void __ae_cursor_set_raw_value(AE_CURSOR *cursor, AE_ITEM *value);
extern int __ae_cursor_get_keyv(AE_CURSOR *cursor, uint32_t flags, va_list ap);
extern void __ae_cursor_set_keyv(AE_CURSOR *cursor, uint32_t flags, va_list ap);
extern int __ae_cursor_get_value(AE_CURSOR *cursor, ...);
extern int __ae_cursor_get_valuev(AE_CURSOR *cursor, va_list ap);
extern void __ae_cursor_set_value(AE_CURSOR *cursor, ...);
extern void __ae_cursor_set_valuev(AE_CURSOR *cursor, va_list ap);
extern int __ae_cursor_close(AE_CURSOR *cursor);
extern int __ae_cursor_equals(AE_CURSOR *cursor, AE_CURSOR *other, int *equalp);
extern int __ae_cursor_reconfigure(AE_CURSOR *cursor, const char *config);
extern int __ae_cursor_dup_position(AE_CURSOR *to_dup, AE_CURSOR *cursor);
extern int __ae_cursor_init(AE_CURSOR *cursor, const char *uri, AE_CURSOR *owner, const char *cfg[], AE_CURSOR **cursorp);
extern int __ae_apply_single_idx(AE_SESSION_IMPL *session, AE_INDEX *idx, AE_CURSOR *cur, AE_CURSOR_TABLE *ctable, int (*f)(AE_CURSOR *));
extern int __ae_curtable_get_key(AE_CURSOR *cursor, ...);
extern int __ae_curtable_get_value(AE_CURSOR *cursor, ...);
extern void __ae_curtable_set_key(AE_CURSOR *cursor, ...);
extern void __ae_curtable_set_value(AE_CURSOR *cursor, ...);
extern int __ae_table_range_truncate(AE_CURSOR_TABLE *start, AE_CURSOR_TABLE *stop);
extern int __ae_curtable_open(AE_SESSION_IMPL *session, const char *uri, AE_CURSOR *owner, const char *cfg[], AE_CURSOR **cursorp);
extern int __ae_evict_file(AE_SESSION_IMPL *session, AE_CACHE_OP syncop);
extern void __ae_evict_list_clear_page(AE_SESSION_IMPL *session, AE_REF *ref);
extern int __ae_evict_server_wake(AE_SESSION_IMPL *session);
extern int __ae_evict_create(AE_SESSION_IMPL *session);
extern int __ae_evict_destroy(AE_SESSION_IMPL *session);
extern int __ae_evict_file_exclusive_on(AE_SESSION_IMPL *session, bool *evict_resetp);
extern void __ae_evict_file_exclusive_off(AE_SESSION_IMPL *session);
extern int __ae_cache_eviction_worker(AE_SESSION_IMPL *session, bool busy, u_int pct_full);
extern int __ae_cache_dump(AE_SESSION_IMPL *session, const char *ofile);
extern int __ae_evict(AE_SESSION_IMPL *session, AE_REF *ref, bool closing);
extern int __ae_evict_page_clean_update( AE_SESSION_IMPL *session, AE_REF *ref, bool closing);
extern int __ae_log_ckpt(AE_SESSION_IMPL *session, AE_LSN *ckp_lsn);
extern int __ae_log_flush_lsn(AE_SESSION_IMPL *session, AE_LSN *lsn, bool start);
extern int __ae_log_background(AE_SESSION_IMPL *session, AE_LSN *lsn);
extern int __ae_log_force_sync(AE_SESSION_IMPL *session, AE_LSN *min_lsn);
extern int __ae_log_needs_recovery(AE_SESSION_IMPL *session, AE_LSN *ckp_lsn, bool *recp);
extern void __ae_log_written_reset(AE_SESSION_IMPL *session);
extern int __ae_log_get_all_files(AE_SESSION_IMPL *session, char ***filesp, u_int *countp, uint32_t *maxid, bool active_only);
extern void __ae_log_files_free(AE_SESSION_IMPL *session, char **files, u_int count);
extern int __ae_log_extract_lognum( AE_SESSION_IMPL *session, const char *name, uint32_t *id);
extern int __ae_log_acquire(AE_SESSION_IMPL *session, uint64_t recsize, AE_LOGSLOT *slot);
extern int __ae_log_allocfile( AE_SESSION_IMPL *session, uint32_t lognum, const char *dest);
extern int __ae_log_remove(AE_SESSION_IMPL *session, const char *file_prefix, uint32_t lognum);
extern int __ae_log_open(AE_SESSION_IMPL *session);
extern int __ae_log_close(AE_SESSION_IMPL *session);
extern int __ae_log_release(AE_SESSION_IMPL *session, AE_LOGSLOT *slot, bool *freep);
extern int __ae_log_scan(AE_SESSION_IMPL *session, AE_LSN *lsnp, uint32_t flags, int (*func)(AE_SESSION_IMPL *session, AE_ITEM *record, AE_LSN *lsnp, AE_LSN *next_lsnp, void *cookie, int firstrecord), void *cookie);
extern int __ae_log_force_write(AE_SESSION_IMPL *session, bool retry);
extern int __ae_log_write(AE_SESSION_IMPL *session, AE_ITEM *record, AE_LSN *lsnp, uint32_t flags);
extern int __ae_log_vprintf(AE_SESSION_IMPL *session, const char *fmt, va_list ap);
extern int __ae_log_flush(AE_SESSION_IMPL *session, uint32_t flags);
extern int __ae_logrec_alloc(AE_SESSION_IMPL *session, size_t size, AE_ITEM **logrecp);
extern void __ae_logrec_free(AE_SESSION_IMPL *session, AE_ITEM **logrecp);
extern int __ae_logrec_read(AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, uint32_t *rectypep);
extern int __ae_logop_read(AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, uint32_t *optypep, uint32_t *opsizep);
extern int __ae_logop_col_put_pack( AE_SESSION_IMPL *session, AE_ITEM *logrec, uint32_t fileid, uint64_t recno, AE_ITEM *value);
extern int __ae_logop_col_put_unpack( AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, uint32_t *fileidp, uint64_t *recnop, AE_ITEM *valuep);
extern int __ae_logop_col_put_print( AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, FILE *out);
extern int __ae_logop_col_remove_pack( AE_SESSION_IMPL *session, AE_ITEM *logrec, uint32_t fileid, uint64_t recno);
extern int __ae_logop_col_remove_unpack( AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, uint32_t *fileidp, uint64_t *recnop);
extern int __ae_logop_col_remove_print( AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, FILE *out);
extern int __ae_logop_col_truncate_pack( AE_SESSION_IMPL *session, AE_ITEM *logrec, uint32_t fileid, uint64_t start, uint64_t stop);
extern int __ae_logop_col_truncate_unpack( AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, uint32_t *fileidp, uint64_t *startp, uint64_t *stopp);
extern int __ae_logop_col_truncate_print( AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, FILE *out);
extern int __ae_logop_row_put_pack( AE_SESSION_IMPL *session, AE_ITEM *logrec, uint32_t fileid, AE_ITEM *key, AE_ITEM *value);
extern int __ae_logop_row_put_unpack( AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, uint32_t *fileidp, AE_ITEM *keyp, AE_ITEM *valuep);
extern int __ae_logop_row_put_print( AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, FILE *out);
extern int __ae_logop_row_remove_pack( AE_SESSION_IMPL *session, AE_ITEM *logrec, uint32_t fileid, AE_ITEM *key);
extern int __ae_logop_row_remove_unpack( AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, uint32_t *fileidp, AE_ITEM *keyp);
extern int __ae_logop_row_remove_print( AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, FILE *out);
extern int __ae_logop_row_truncate_pack( AE_SESSION_IMPL *session, AE_ITEM *logrec, uint32_t fileid, AE_ITEM *start, AE_ITEM *stop, uint32_t mode);
extern int __ae_logop_row_truncate_unpack( AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, uint32_t *fileidp, AE_ITEM *startp, AE_ITEM *stopp, uint32_t *modep);
extern int __ae_logop_row_truncate_print( AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, FILE *out);
extern int __ae_txn_op_printlog( AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, FILE *out);
extern void __ae_log_slot_activate(AE_SESSION_IMPL *session, AE_LOGSLOT *slot);
extern int __ae_log_slot_switch( AE_SESSION_IMPL *session, AE_MYSLOT *myslot, bool retry, bool forced);
extern int __ae_log_slot_new(AE_SESSION_IMPL *session);
extern int __ae_log_slot_init(AE_SESSION_IMPL *session);
extern int __ae_log_slot_destroy(AE_SESSION_IMPL *session);
extern void __ae_log_slot_join(AE_SESSION_IMPL *session, uint64_t mysize, uint32_t flags, AE_MYSLOT *myslot);
extern int64_t __ae_log_slot_release(AE_SESSION_IMPL *session, AE_MYSLOT *myslot, int64_t size);
extern void __ae_log_slot_free(AE_SESSION_IMPL *session, AE_LOGSLOT *slot);
extern int __ae_clsm_request_switch(AE_CURSOR_LSM *clsm);
extern int __ae_clsm_await_switch(AE_CURSOR_LSM *clsm);
extern int __ae_clsm_init_merge( AE_CURSOR *cursor, u_int start_chunk, uint32_t start_id, u_int nchunks);
extern int __ae_clsm_close(AE_CURSOR *cursor);
extern int __ae_clsm_open(AE_SESSION_IMPL *session, const char *uri, AE_CURSOR *owner, const char *cfg[], AE_CURSOR **cursorp);
extern int __ae_clsm_open_bulk(AE_CURSOR_LSM *clsm, const char *cfg[]);
extern int __ae_lsm_manager_config(AE_SESSION_IMPL *session, const char **cfg);
extern int __ae_lsm_manager_reconfig(AE_SESSION_IMPL *session, const char **cfg);
extern int __ae_lsm_manager_start(AE_SESSION_IMPL *session);
extern void __ae_lsm_manager_free_work_unit( AE_SESSION_IMPL *session, AE_LSM_WORK_UNIT *entry);
extern int __ae_lsm_manager_destroy(AE_SESSION_IMPL *session);
extern int __ae_lsm_manager_clear_tree( AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree);
extern int __ae_lsm_manager_pop_entry( AE_SESSION_IMPL *session, uint32_t type, AE_LSM_WORK_UNIT **entryp);
extern int __ae_lsm_manager_push_entry(AE_SESSION_IMPL *session, uint32_t type, uint32_t flags, AE_LSM_TREE *lsm_tree);
extern int __ae_lsm_merge_update_tree(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree, u_int start_chunk, u_int nchunks, AE_LSM_CHUNK *chunk);
extern int __ae_lsm_merge(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree, u_int id);
extern int __ae_lsm_meta_read(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree);
extern int __ae_lsm_meta_write(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree);
extern int __ae_curstat_lsm_init( AE_SESSION_IMPL *session, const char *uri, AE_CURSOR_STAT *cst);
extern int __ae_lsm_tree_close_all(AE_SESSION_IMPL *session);
extern int __ae_lsm_tree_bloom_name(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree, uint32_t id, const char **retp);
extern int __ae_lsm_tree_chunk_name(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree, uint32_t id, const char **retp);
extern int __ae_lsm_tree_set_chunk_size( AE_SESSION_IMPL *session, AE_LSM_CHUNK *chunk);
extern int __ae_lsm_tree_setup_chunk( AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree, AE_LSM_CHUNK *chunk);
extern int __ae_lsm_tree_setup_bloom( AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree, AE_LSM_CHUNK *chunk);
extern int __ae_lsm_tree_create(AE_SESSION_IMPL *session, const char *uri, bool exclusive, const char *config);
extern int __ae_lsm_tree_get(AE_SESSION_IMPL *session, const char *uri, bool exclusive, AE_LSM_TREE **treep);
extern void __ae_lsm_tree_release(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree);
extern void __ae_lsm_tree_throttle( AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree, bool decrease_only);
extern int __ae_lsm_tree_switch(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree);
extern int __ae_lsm_tree_retire_chunks(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree, u_int start_chunk, u_int nchunks);
extern int __ae_lsm_tree_drop( AE_SESSION_IMPL *session, const char *name, const char *cfg[]);
extern int __ae_lsm_tree_rename(AE_SESSION_IMPL *session, const char *olduri, const char *newuri, const char *cfg[]);
extern int __ae_lsm_tree_truncate( AE_SESSION_IMPL *session, const char *name, const char *cfg[]);
extern int __ae_lsm_tree_readlock(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree);
extern int __ae_lsm_tree_readunlock(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree);
extern int __ae_lsm_tree_writelock(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree);
extern int __ae_lsm_tree_writeunlock(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree);
extern int __ae_lsm_compact(AE_SESSION_IMPL *session, const char *name, bool *skipp);
extern int __ae_lsm_tree_worker(AE_SESSION_IMPL *session, const char *uri, int (*file_func)(AE_SESSION_IMPL *, const char *[]), int (*name_func)(AE_SESSION_IMPL *, const char *, bool *), const char *cfg[], uint32_t open_flags);
extern int __ae_lsm_get_chunk_to_flush(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree, bool force, AE_LSM_CHUNK **chunkp);
extern int __ae_lsm_work_switch( AE_SESSION_IMPL *session, AE_LSM_WORK_UNIT **entryp, bool *ran);
extern int __ae_lsm_work_bloom(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree);
extern int __ae_lsm_checkpoint_chunk(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree, AE_LSM_CHUNK *chunk);
extern int __ae_lsm_free_chunks(AE_SESSION_IMPL *session, AE_LSM_TREE *lsm_tree);
extern int __ae_lsm_worker_start(AE_SESSION_IMPL *session, AE_LSM_WORKER_ARGS *args);
extern int __ae_meta_btree_apply(AE_SESSION_IMPL *session, int (*func)(AE_SESSION_IMPL *, const char *[]), const char *cfg[]);
extern int __ae_meta_checkpoint(AE_SESSION_IMPL *session, const char *fname, const char *checkpoint, AE_CKPT *ckpt);
extern int __ae_meta_checkpoint_last_name( AE_SESSION_IMPL *session, const char *fname, const char **namep);
extern int __ae_meta_checkpoint_clear(AE_SESSION_IMPL *session, const char *fname);
extern int __ae_meta_ckptlist_get( AE_SESSION_IMPL *session, const char *fname, AE_CKPT **ckptbasep);
extern int __ae_meta_ckptlist_set(AE_SESSION_IMPL *session, const char *fname, AE_CKPT *ckptbase, AE_LSN *ckptlsn);
extern void __ae_meta_ckptlist_free(AE_SESSION_IMPL *session, AE_CKPT *ckptbase);
extern void __ae_meta_checkpoint_free(AE_SESSION_IMPL *session, AE_CKPT *ckpt);
extern int __ae_ext_metadata_insert(AE_EXTENSION_API *ae_api, AE_SESSION *ae_session, const char *key, const char *value);
extern int __ae_ext_metadata_remove( AE_EXTENSION_API *ae_api, AE_SESSION *ae_session, const char *key);
extern int __ae_ext_metadata_search(AE_EXTENSION_API *ae_api, AE_SESSION *ae_session, const char *key, char **valuep);
extern int __ae_ext_metadata_update(AE_EXTENSION_API *ae_api, AE_SESSION *ae_session, const char *key, const char *value);
extern int __ae_metadata_get_ckptlist( AE_SESSION *session, const char *name, AE_CKPT **ckptbasep);
extern void __ae_metadata_free_ckptlist(AE_SESSION *session, AE_CKPT *ckptbase);
extern int __ae_metadata_open(AE_SESSION_IMPL *session);
extern int __ae_metadata_cursor( AE_SESSION_IMPL *session, const char *config, AE_CURSOR **cursorp);
extern int __ae_metadata_insert( AE_SESSION_IMPL *session, const char *key, const char *value);
extern int __ae_metadata_update( AE_SESSION_IMPL *session, const char *key, const char *value);
extern int __ae_metadata_remove(AE_SESSION_IMPL *session, const char *key);
extern int __ae_metadata_search( AE_SESSION_IMPL *session, const char *key, char **valuep);
extern void __ae_meta_track_discard(AE_SESSION_IMPL *session);
extern int __ae_meta_track_on(AE_SESSION_IMPL *session);
extern int __ae_meta_track_off(AE_SESSION_IMPL *session, bool need_sync, bool unroll);
extern int __ae_meta_track_sub_on(AE_SESSION_IMPL *session);
extern int __ae_meta_track_sub_off(AE_SESSION_IMPL *session);
extern int __ae_meta_track_checkpoint(AE_SESSION_IMPL *session);
extern int __ae_meta_track_insert(AE_SESSION_IMPL *session, const char *key);
extern int __ae_meta_track_update(AE_SESSION_IMPL *session, const char *key);
extern int __ae_meta_track_fileop( AE_SESSION_IMPL *session, const char *olduri, const char *newuri);
extern int __ae_meta_track_drop( AE_SESSION_IMPL *session, const char *filename);
extern int __ae_meta_track_handle_lock(AE_SESSION_IMPL *session, bool created);
extern int __ae_meta_track_init(AE_SESSION_IMPL *session);
extern int __ae_meta_track_destroy(AE_SESSION_IMPL *session);
extern int __ae_turtle_init(AE_SESSION_IMPL *session);
extern int __ae_turtle_read(AE_SESSION_IMPL *session, const char *key, char **valuep);
extern int __ae_turtle_update( AE_SESSION_IMPL *session, const char *key, const char *value);
extern void __ae_abort(AE_SESSION_IMPL *session) AE_GCC_FUNC_DECL_ATTRIBUTE((noreturn));
extern int __ae_calloc(AE_SESSION_IMPL *session, size_t number, size_t size, void *retp);
extern int __ae_realloc(AE_SESSION_IMPL *session, size_t *bytes_allocated_ret, size_t bytes_to_allocate, void *retp);
extern int __ae_realloc_aligned(AE_SESSION_IMPL *session, size_t *bytes_allocated_ret, size_t bytes_to_allocate, void *retp);
extern int __ae_strndup(AE_SESSION_IMPL *session, const void *str, size_t len, void *retp);
extern void __ae_free_int(AE_SESSION_IMPL *session, const void *p_arg);
extern int __ae_dirlist(AE_SESSION_IMPL *session, const char *dir, const char *prefix, uint32_t flags, char ***dirlist, u_int *countp);
extern int __ae_dlopen(AE_SESSION_IMPL *session, const char *path, AE_DLH **dlhp);
extern int __ae_dlsym(AE_SESSION_IMPL *session, AE_DLH *dlh, const char *name, bool fail, void *sym_ret);
extern int __ae_dlclose(AE_SESSION_IMPL *session, AE_DLH *dlh);
extern int __ae_errno(void);
extern const char *__ae_strerror(AE_SESSION_IMPL *session, int error, char *errbuf, size_t errlen);
extern int __ae_exist(AE_SESSION_IMPL *session, const char *filename, bool *existp);
extern void __ae_fallocate_config(AE_SESSION_IMPL *session, AE_FH *fh);
extern int __ae_fallocate( AE_SESSION_IMPL *session, AE_FH *fh, ae_off_t offset, ae_off_t len);
extern int __ae_filesize(AE_SESSION_IMPL *session, AE_FH *fh, ae_off_t *sizep);
extern int __ae_filesize_name(AE_SESSION_IMPL *session, const char *filename, bool silent, ae_off_t *sizep);
extern int __ae_bytelock(AE_FH *fhp, ae_off_t byte, bool lock);
extern int __ae_directory_sync_fh(AE_SESSION_IMPL *session, AE_FH *fh);
extern int __ae_directory_sync(AE_SESSION_IMPL *session, char *path);
extern int __ae_fsync(AE_SESSION_IMPL *session, AE_FH *fh);
extern int __ae_fsync_async(AE_SESSION_IMPL *session, AE_FH *fh);
extern int __ae_ftruncate(AE_SESSION_IMPL *session, AE_FH *fh, ae_off_t len);
extern int __ae_getenv(AE_SESSION_IMPL *session, const char *variable, const char **envp);
extern int __ae_getline(AE_SESSION_IMPL *session, AE_ITEM *buf, FILE *fp);
extern int __ae_getopt( const char *progname, int nargc, char *const *nargv, const char *ostr);
extern int __ae_mmap(AE_SESSION_IMPL *session, AE_FH *fh, void *mapp, size_t *lenp, void **mappingcookie);
extern int __ae_mmap_preload(AE_SESSION_IMPL *session, const void *p, size_t size);
extern int __ae_mmap_discard(AE_SESSION_IMPL *session, void *p, size_t size);
extern int __ae_munmap(AE_SESSION_IMPL *session, AE_FH *fh, void *map, size_t len, void **mappingcookie);
extern int __ae_cond_alloc(AE_SESSION_IMPL *session, const char *name, bool is_signalled, AE_CONDVAR **condp);
extern int __ae_cond_wait_signal( AE_SESSION_IMPL *session, AE_CONDVAR *cond, uint64_t usecs, bool *signalled);
extern int __ae_cond_signal(AE_SESSION_IMPL *session, AE_CONDVAR *cond);
extern int __ae_cond_destroy(AE_SESSION_IMPL *session, AE_CONDVAR **condp);
extern int __ae_rwlock_alloc( AE_SESSION_IMPL *session, AE_RWLOCK **rwlockp, const char *name);
extern int __ae_try_readlock(AE_SESSION_IMPL *session, AE_RWLOCK *rwlock);
extern int __ae_readlock(AE_SESSION_IMPL *session, AE_RWLOCK *rwlock);
extern int __ae_readunlock(AE_SESSION_IMPL *session, AE_RWLOCK *rwlock);
extern int __ae_try_writelock(AE_SESSION_IMPL *session, AE_RWLOCK *rwlock);
extern int __ae_writelock(AE_SESSION_IMPL *session, AE_RWLOCK *rwlock);
extern int __ae_writeunlock(AE_SESSION_IMPL *session, AE_RWLOCK *rwlock);
extern int __ae_rwlock_destroy(AE_SESSION_IMPL *session, AE_RWLOCK **rwlockp);
extern int __ae_once(void (*init_routine)(void));
extern int __ae_open(AE_SESSION_IMPL *session, const char *name, bool ok_create, bool exclusive, int dio_type, AE_FH **fhp);
extern int __ae_close(AE_SESSION_IMPL *session, AE_FH **fhp);
extern bool __ae_absolute_path(const char *path);
extern const char *__ae_path_separator(void);
extern bool __ae_has_priv(void);
extern int __ae_remove(AE_SESSION_IMPL *session, const char *name);
extern int __ae_rename(AE_SESSION_IMPL *session, const char *from, const char *to);
extern int __ae_read( AE_SESSION_IMPL *session, AE_FH *fh, ae_off_t offset, size_t len, void *buf);
extern int __ae_write(AE_SESSION_IMPL *session, AE_FH *fh, ae_off_t offset, size_t len, const void *buf);
extern void __ae_sleep(uint64_t seconds, uint64_t micro_seconds);
extern int __ae_fopen(AE_SESSION_IMPL *session, const char *name, AE_FHANDLE_MODE mode_flag, u_int flags, FILE **fpp);
extern int __ae_vfprintf(FILE *fp, const char *fmt, va_list ap);
extern int __ae_fprintf(FILE *fp, const char *fmt, ...) AE_GCC_FUNC_DECL_ATTRIBUTE((format (printf, 2, 3)));
extern int __ae_fflush(FILE *fp);
extern int __ae_fclose(FILE **fpp, AE_FHANDLE_MODE mode_flag);
extern uint64_t __ae_strtouq(const char *nptr, char **endptr, int base);
extern int __ae_thread_create(AE_SESSION_IMPL *session, ae_thread_t *tidret, AE_THREAD_CALLBACK(*func)(void *), void *arg);
extern int __ae_thread_join(AE_SESSION_IMPL *session, ae_thread_t tid);
extern void __ae_thread_id(char *buf, size_t buflen);
extern int __ae_epoch(AE_SESSION_IMPL *session, struct timespec *tsp);
extern void __ae_yield(void);
extern int __ae_ext_struct_pack(AE_EXTENSION_API *ae_api, AE_SESSION *ae_session, void *buffer, size_t size, const char *fmt, ...);
extern int __ae_ext_struct_size(AE_EXTENSION_API *ae_api, AE_SESSION *ae_session, size_t *sizep, const char *fmt, ...);
extern int __ae_ext_struct_unpack(AE_EXTENSION_API *ae_api, AE_SESSION *ae_session, const void *buffer, size_t size, const char *fmt, ...);
extern int __ae_struct_check(AE_SESSION_IMPL *session, const char *fmt, size_t len, bool *fixedp, uint32_t *fixed_lenp);
extern int __ae_struct_confchk(AE_SESSION_IMPL *session, AE_CONFIG_ITEM *v);
extern int __ae_struct_size(AE_SESSION_IMPL *session, size_t *sizep, const char *fmt, ...);
extern int __ae_struct_pack(AE_SESSION_IMPL *session, void *buffer, size_t size, const char *fmt, ...);
extern int __ae_struct_unpack(AE_SESSION_IMPL *session, const void *buffer, size_t size, const char *fmt, ...);
extern int __ae_struct_unpack_size(AE_SESSION_IMPL *session, const void *buffer, size_t size, const char *fmt, size_t *resultp);
extern int __ae_struct_repack(AE_SESSION_IMPL *session, const char *infmt, const char *outfmt, const AE_ITEM *inbuf, AE_ITEM *outbuf, void **reallocp);
extern int __ae_ovfl_discard_add(AE_SESSION_IMPL *session, AE_PAGE *page, AE_CELL *cell);
extern void __ae_ovfl_discard_free(AE_SESSION_IMPL *session, AE_PAGE *page);
extern int __ae_ovfl_reuse_search(AE_SESSION_IMPL *session, AE_PAGE *page, uint8_t **addrp, size_t *addr_sizep, const void *value, size_t value_size);
extern int __ae_ovfl_reuse_add(AE_SESSION_IMPL *session, AE_PAGE *page, const uint8_t *addr, size_t addr_size, const void *value, size_t value_size);
extern void __ae_ovfl_reuse_free(AE_SESSION_IMPL *session, AE_PAGE *page);
extern int __ae_ovfl_txnc_search( AE_PAGE *page, const uint8_t *addr, size_t addr_size, AE_ITEM *store);
extern int __ae_ovfl_txnc_add(AE_SESSION_IMPL *session, AE_PAGE *page, const uint8_t *addr, size_t addr_size, const void *value, size_t value_size);
extern void __ae_ovfl_txnc_free(AE_SESSION_IMPL *session, AE_PAGE *page);
extern int __ae_ovfl_track_wrapup(AE_SESSION_IMPL *session, AE_PAGE *page);
extern int __ae_ovfl_track_wrapup_err(AE_SESSION_IMPL *session, AE_PAGE *page);
extern int __ae_reconcile(AE_SESSION_IMPL *session, AE_REF *ref, AE_SALVAGE_COOKIE *salvage, uint32_t flags);
extern uint32_t __ae_split_page_size(AE_BTREE *btree, uint32_t maxpagesize);
extern int __ae_bulk_init(AE_SESSION_IMPL *session, AE_CURSOR_BULK *cbulk);
extern int __ae_bulk_wrapup(AE_SESSION_IMPL *session, AE_CURSOR_BULK *cbulk);
extern int __ae_bulk_insert_row(AE_SESSION_IMPL *session, AE_CURSOR_BULK *cbulk);
extern int __ae_bulk_insert_fix(AE_SESSION_IMPL *session, AE_CURSOR_BULK *cbulk);
extern int __ae_bulk_insert_var(AE_SESSION_IMPL *session, AE_CURSOR_BULK *cbulk);
extern int __ae_schema_create_strip(AE_SESSION_IMPL *session, const char *v1, const char *v2, char **value_ret);
extern int __ae_direct_io_size_check(AE_SESSION_IMPL *session, const char **cfg, const char *config_name, uint32_t *allocsizep);
extern int __ae_schema_colgroup_source(AE_SESSION_IMPL *session, AE_TABLE *table, const char *cgname, const char *config, AE_ITEM *buf);
extern int __ae_schema_index_source(AE_SESSION_IMPL *session, AE_TABLE *table, const char *idxname, const char *config, AE_ITEM *buf);
extern int __ae_schema_create( AE_SESSION_IMPL *session, const char *uri, const char *config);
extern int __ae_schema_drop(AE_SESSION_IMPL *session, const char *uri, const char *cfg[]);
extern int __ae_schema_get_table(AE_SESSION_IMPL *session, const char *name, size_t namelen, bool ok_incomplete, AE_TABLE **tablep);
extern void __ae_schema_release_table(AE_SESSION_IMPL *session, AE_TABLE *table);
extern void __ae_schema_destroy_colgroup(AE_SESSION_IMPL *session, AE_COLGROUP **colgroupp);
extern int __ae_schema_destroy_index(AE_SESSION_IMPL *session, AE_INDEX **idxp);
extern int __ae_schema_destroy_table(AE_SESSION_IMPL *session, AE_TABLE **tablep);
extern int __ae_schema_remove_table(AE_SESSION_IMPL *session, AE_TABLE *table);
extern int __ae_schema_close_tables(AE_SESSION_IMPL *session);
extern int __ae_schema_colgroup_name(AE_SESSION_IMPL *session, AE_TABLE *table, const char *cgname, size_t len, AE_ITEM *buf);
extern int __ae_schema_open_colgroups(AE_SESSION_IMPL *session, AE_TABLE *table);
extern int __ae_schema_open_index(AE_SESSION_IMPL *session, AE_TABLE *table, const char *idxname, size_t len, AE_INDEX **indexp);
extern int __ae_schema_open_indices(AE_SESSION_IMPL *session, AE_TABLE *table);
extern int __ae_schema_get_colgroup(AE_SESSION_IMPL *session, const char *uri, bool quiet, AE_TABLE **tablep, AE_COLGROUP **colgroupp);
extern int __ae_schema_get_index(AE_SESSION_IMPL *session, const char *uri, bool quiet, AE_TABLE **tablep, AE_INDEX **indexp);
extern int __ae_schema_open_table(AE_SESSION_IMPL *session, const char *name, size_t namelen, bool ok_incomplete, AE_TABLE **tablep);
extern int __ae_schema_colcheck(AE_SESSION_IMPL *session, const char *key_format, const char *value_format, AE_CONFIG_ITEM *colconf, u_int *kcolsp, u_int *vcolsp);
extern int __ae_table_check(AE_SESSION_IMPL *session, AE_TABLE *table);
extern int __ae_struct_plan(AE_SESSION_IMPL *session, AE_TABLE *table, const char *columns, size_t len, bool value_only, AE_ITEM *plan);
extern int __ae_struct_reformat(AE_SESSION_IMPL *session, AE_TABLE *table, const char *columns, size_t len, const char *extra_cols, bool value_only, AE_ITEM *format);
extern int __ae_struct_truncate(AE_SESSION_IMPL *session, const char *input_fmt, u_int ncols, AE_ITEM *format);
extern int __ae_schema_project_in(AE_SESSION_IMPL *session, AE_CURSOR **cp, const char *proj_arg, va_list ap);
extern int __ae_schema_project_out(AE_SESSION_IMPL *session, AE_CURSOR **cp, const char *proj_arg, va_list ap);
extern int __ae_schema_project_slice(AE_SESSION_IMPL *session, AE_CURSOR **cp, const char *proj_arg, bool key_only, const char *vformat, AE_ITEM *value);
extern int __ae_schema_project_merge(AE_SESSION_IMPL *session, AE_CURSOR **cp, const char *proj_arg, const char *vformat, AE_ITEM *value);
extern int __ae_schema_rename(AE_SESSION_IMPL *session, const char *uri, const char *newuri, const char *cfg[]);
extern int __ae_curstat_colgroup_init(AE_SESSION_IMPL *session, const char *uri, const char *cfg[], AE_CURSOR_STAT *cst);
extern int __ae_curstat_index_init(AE_SESSION_IMPL *session, const char *uri, const char *cfg[], AE_CURSOR_STAT *cst);
extern int __ae_curstat_table_init(AE_SESSION_IMPL *session, const char *uri, const char *cfg[], AE_CURSOR_STAT *cst);
extern int __ae_schema_truncate( AE_SESSION_IMPL *session, const char *uri, const char *cfg[]);
extern int __ae_range_truncate(AE_CURSOR *start, AE_CURSOR *stop);
extern int __ae_schema_range_truncate( AE_SESSION_IMPL *session, AE_CURSOR *start, AE_CURSOR *stop);
extern AE_DATA_SOURCE *__ae_schema_get_source(AE_SESSION_IMPL *session, const char *name);
extern int __ae_str_name_check(AE_SESSION_IMPL *session, const char *str);
extern int __ae_name_check(AE_SESSION_IMPL *session, const char *str, size_t len);
extern int __ae_schema_worker(AE_SESSION_IMPL *session, const char *uri, int (*file_func)(AE_SESSION_IMPL *, const char *[]), int (*name_func)(AE_SESSION_IMPL *, const char *, bool *), const char *cfg[], uint32_t open_flags);
extern int __ae_session_reset_cursors(AE_SESSION_IMPL *session, bool free_buffers);
extern int __ae_session_copy_values(AE_SESSION_IMPL *session);
extern int __ae_session_release_resources(AE_SESSION_IMPL *session);
extern int __ae_open_cursor(AE_SESSION_IMPL *session, const char *uri, AE_CURSOR *owner, const char *cfg[], AE_CURSOR **cursorp);
extern int __ae_session_create( AE_SESSION_IMPL *session, const char *uri, const char *config);
extern int __ae_session_drop(AE_SESSION_IMPL *session, const char *uri, const char *cfg[]);
extern int __ae_open_session(AE_CONNECTION_IMPL *conn, AE_EVENT_HANDLER *event_handler, const char *config, bool open_metadata, AE_SESSION_IMPL **sessionp);
extern int __ae_open_internal_session(AE_CONNECTION_IMPL *conn, const char *name, bool open_metadata, uint32_t session_flags, AE_SESSION_IMPL **sessionp);
extern int __ae_compact_uri_analyze(AE_SESSION_IMPL *session, const char *uri, bool *skipp);
extern int __ae_session_compact( AE_SESSION *ae_session, const char *uri, const char *config);
extern int __ae_session_lock_dhandle( AE_SESSION_IMPL *session, uint32_t flags, bool *is_deadp);
extern int __ae_session_release_btree(AE_SESSION_IMPL *session);
extern int __ae_session_get_btree_ckpt(AE_SESSION_IMPL *session, const char *uri, const char *cfg[], uint32_t flags);
extern void __ae_session_close_cache(AE_SESSION_IMPL *session);
extern int __ae_session_get_btree(AE_SESSION_IMPL *session, const char *uri, const char *checkpoint, const char *cfg[], uint32_t flags);
extern int __ae_session_lock_checkpoint(AE_SESSION_IMPL *session, const char *checkpoint);
extern int __ae_salvage(AE_SESSION_IMPL *session, const char *cfg[]);
extern uint32_t __ae_cksum(const void *chunk, size_t len);
extern void __ae_cksum_init(void);
extern int __ae_decrypt(AE_SESSION_IMPL *session, AE_ENCRYPTOR *encryptor, size_t skip, AE_ITEM *in, AE_ITEM *out);
extern int __ae_encrypt(AE_SESSION_IMPL *session, AE_KEYED_ENCRYPTOR *kencryptor, size_t skip, AE_ITEM *in, AE_ITEM *out);
extern void __ae_encrypt_size(AE_SESSION_IMPL *session, AE_KEYED_ENCRYPTOR *kencryptor, size_t incoming_size, size_t *sizep);
extern void __ae_event_handler_set(AE_SESSION_IMPL *session, AE_EVENT_HANDLER *handler);
extern int __ae_eventv(AE_SESSION_IMPL *session, bool msg_event, int error, const char *file_name, int line_number, const char *fmt, va_list ap);
extern void __ae_err(AE_SESSION_IMPL *session, int error, const char *fmt, ...) AE_GCC_FUNC_DECL_ATTRIBUTE((format (printf, 3, 4)));
extern void __ae_errx(AE_SESSION_IMPL *session, const char *fmt, ...) AE_GCC_FUNC_DECL_ATTRIBUTE((format (printf, 2, 3)));
extern int __ae_ext_err_printf( AE_EXTENSION_API *ae_api, AE_SESSION *ae_session, const char *fmt, ...) AE_GCC_FUNC_DECL_ATTRIBUTE((format (printf, 3, 4)));
extern int __ae_msg(AE_SESSION_IMPL *session, const char *fmt, ...) AE_GCC_FUNC_DECL_ATTRIBUTE((format (printf, 2, 3)));
extern int __ae_ext_msg_printf( AE_EXTENSION_API *ae_api, AE_SESSION *ae_session, const char *fmt, ...) AE_GCC_FUNC_DECL_ATTRIBUTE((format (printf, 3, 4)));
extern const char *__ae_ext_strerror(AE_EXTENSION_API *ae_api, AE_SESSION *ae_session, int error);
extern int __ae_progress(AE_SESSION_IMPL *session, const char *s, uint64_t v);
extern void __ae_assert(AE_SESSION_IMPL *session, int error, const char *file_name, int line_number, const char *fmt, ...) AE_GCC_FUNC_DECL_ATTRIBUTE((format (printf, 5, 6)));
extern int __ae_panic(AE_SESSION_IMPL *session);
extern int __ae_illegal_value(AE_SESSION_IMPL *session, const char *name);
extern int __ae_object_unsupported(AE_SESSION_IMPL *session, const char *uri);
extern int __ae_bad_object_type(AE_SESSION_IMPL *session, const char *uri);
extern int __ae_filename(AE_SESSION_IMPL *session, const char *name, char **path);
extern int __ae_nfilename( AE_SESSION_IMPL *session, const char *name, size_t namelen, char **path);
extern int __ae_remove_if_exists(AE_SESSION_IMPL *session, const char *name);
extern int __ae_sync_and_rename_fh( AE_SESSION_IMPL *session, AE_FH **fhp, const char *from, const char *to);
extern int __ae_sync_and_rename_fp( AE_SESSION_IMPL *session, FILE **fpp, const char *from, const char *to);
extern int __ae_library_init(void);
extern int __ae_breakpoint(void);
extern void __ae_attach(AE_SESSION_IMPL *session);
extern uint64_t __ae_hash_city64(const void *s, size_t len);
extern uint64_t __ae_hash_fnv64(const void *string, size_t len);
extern int
__ae_hazard_set(AE_SESSION_IMPL *session, AE_REF *ref, bool *busyp
#ifdef HAVE_DIAGNOSTIC
 , const char *file, int line
#endif
 );
extern int __ae_hazard_clear(AE_SESSION_IMPL *session, AE_PAGE *page);
extern void __ae_hazard_close(AE_SESSION_IMPL *session);
extern int __ae_raw_to_hex( AE_SESSION_IMPL *session, const uint8_t *from, size_t size, AE_ITEM *to);
extern int __ae_raw_to_esc_hex( AE_SESSION_IMPL *session, const uint8_t *from, size_t size, AE_ITEM *to);
extern int __ae_hex2byte(const u_char *from, u_char *to);
extern int __ae_hex_to_raw(AE_SESSION_IMPL *session, const char *from, AE_ITEM *to);
extern int __ae_nhex_to_raw( AE_SESSION_IMPL *session, const char *from, size_t size, AE_ITEM *to);
extern int __ae_esc_hex_to_raw(AE_SESSION_IMPL *session, const char *from, AE_ITEM *to);
extern int __ae_huffman_open(AE_SESSION_IMPL *session, void *symbol_frequency_array, u_int symcnt, u_int numbytes, void *retp);
extern void __ae_huffman_close(AE_SESSION_IMPL *session, void *huffman_arg);
extern int __ae_print_huffman_code(void *huffman_arg, uint16_t symbol);
extern int __ae_huffman_encode(AE_SESSION_IMPL *session, void *huffman_arg, const uint8_t *from_arg, size_t from_len, AE_ITEM *to_buf);
extern int __ae_huffman_decode(AE_SESSION_IMPL *session, void *huffman_arg, const uint8_t *from_arg, size_t from_len, AE_ITEM *to_buf);
extern uint32_t __ae_nlpo2_round(uint32_t v);
extern uint32_t __ae_nlpo2(uint32_t v);
extern uint32_t __ae_log2_int(uint32_t n);
extern bool __ae_ispo2(uint32_t v);
extern uint32_t __ae_rduppo2(uint32_t n, uint32_t po2);
extern void __ae_random_init(AE_RAND_STATE volatile *rnd_state);
extern uint32_t __ae_random(AE_RAND_STATE volatile *rnd_state);
extern int __ae_buf_grow_worker(AE_SESSION_IMPL *session, AE_ITEM *buf, size_t size);
extern int __ae_buf_fmt(AE_SESSION_IMPL *session, AE_ITEM *buf, const char *fmt, ...) AE_GCC_FUNC_DECL_ATTRIBUTE((format (printf, 3, 4)));
extern int __ae_buf_catfmt(AE_SESSION_IMPL *session, AE_ITEM *buf, const char *fmt, ...) AE_GCC_FUNC_DECL_ATTRIBUTE((format (printf, 3, 4)));
extern int
__ae_scr_alloc_func(AE_SESSION_IMPL *session, size_t size, AE_ITEM **scratchp
#ifdef HAVE_DIAGNOSTIC
 , const char *file, int line
#endif
 );
extern void __ae_scr_discard(AE_SESSION_IMPL *session);
extern void *__ae_ext_scr_alloc( AE_EXTENSION_API *ae_api, AE_SESSION *ae_session, size_t size);
extern void __ae_ext_scr_free(AE_EXTENSION_API *ae_api, AE_SESSION *ae_session, void *p);
extern int __ae_stat_dsrc_desc(AE_CURSOR_STAT *cst, int slot, const char **p);
extern void __ae_stat_dsrc_init_single(AE_DSRC_STATS *stats);
extern void __ae_stat_dsrc_init(AE_DATA_HANDLE *handle);
extern void __ae_stat_dsrc_clear_single(AE_DSRC_STATS *stats);
extern void __ae_stat_dsrc_clear_all(AE_DSRC_STATS **stats);
extern void __ae_stat_dsrc_aggregate_single( AE_DSRC_STATS *from, AE_DSRC_STATS *to);
extern void __ae_stat_dsrc_aggregate( AE_DSRC_STATS **from, AE_DSRC_STATS *to);
extern int __ae_stat_connection_desc(AE_CURSOR_STAT *cst, int slot, const char **p);
extern void __ae_stat_connection_init_single(AE_CONNECTION_STATS *stats);
extern void __ae_stat_connection_init(AE_CONNECTION_IMPL *handle);
extern void __ae_stat_connection_clear_single(AE_CONNECTION_STATS *stats);
extern void __ae_stat_connection_clear_all(AE_CONNECTION_STATS **stats);
extern void __ae_stat_connection_aggregate( AE_CONNECTION_STATS **from, AE_CONNECTION_STATS *to);
extern int __ae_stat_join_desc(AE_CURSOR_STAT *cst, int slot, const char **p);
extern void __ae_stat_join_init_single(AE_JOIN_STATS *stats);
extern void __ae_stat_join_clear_single(AE_JOIN_STATS *stats);
extern void __ae_stat_join_clear_all(AE_JOIN_STATS **stats);
extern void __ae_stat_join_aggregate( AE_JOIN_STATS **from, AE_JOIN_STATS *to);
extern void __ae_txn_release_snapshot(AE_SESSION_IMPL *session);
extern void __ae_txn_get_snapshot(AE_SESSION_IMPL *session);
extern void __ae_txn_update_oldest(AE_SESSION_IMPL *session, bool force);
extern int __ae_txn_config(AE_SESSION_IMPL *session, const char *cfg[]);
extern void __ae_txn_release(AE_SESSION_IMPL *session);
extern int __ae_txn_commit(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_txn_rollback(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_txn_init(AE_SESSION_IMPL *session);
extern void __ae_txn_stats_update(AE_SESSION_IMPL *session);
extern void __ae_txn_destroy(AE_SESSION_IMPL *session);
extern int __ae_txn_global_init(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_txn_global_destroy(AE_SESSION_IMPL *session);
extern int __ae_checkpoint_name_ok(AE_SESSION_IMPL *session, const char *name, size_t len);
extern int __ae_checkpoint_list(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_txn_checkpoint(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_checkpoint(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_checkpoint_sync(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_checkpoint_close(AE_SESSION_IMPL *session, bool final);
extern uint64_t __ae_ext_transaction_id(AE_EXTENSION_API *ae_api, AE_SESSION *ae_session);
extern int __ae_ext_transaction_isolation_level( AE_EXTENSION_API *ae_api, AE_SESSION *ae_session);
extern int __ae_ext_transaction_notify( AE_EXTENSION_API *ae_api, AE_SESSION *ae_session, AE_TXN_NOTIFY *notify);
extern uint64_t __ae_ext_transaction_oldest(AE_EXTENSION_API *ae_api);
extern int __ae_ext_transaction_visible( AE_EXTENSION_API *ae_api, AE_SESSION *ae_session, uint64_t transaction_id);
extern void __ae_txn_op_free(AE_SESSION_IMPL *session, AE_TXN_OP *op);
extern int __ae_txn_log_op(AE_SESSION_IMPL *session, AE_CURSOR_BTREE *cbt);
extern int __ae_txn_log_commit(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_txn_checkpoint_logread( AE_SESSION_IMPL *session, const uint8_t **pp, const uint8_t *end, AE_LSN *ckpt_lsn);
extern int __ae_txn_checkpoint_log( AE_SESSION_IMPL *session, bool full, uint32_t flags, AE_LSN *lsnp);
extern int __ae_txn_truncate_log( AE_SESSION_IMPL *session, AE_CURSOR_BTREE *start, AE_CURSOR_BTREE *stop);
extern int __ae_txn_truncate_end(AE_SESSION_IMPL *session);
extern int __ae_txn_printlog(AE_SESSION *ae_session, FILE *out);
extern int __ae_txn_named_snapshot_begin(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_txn_named_snapshot_drop(AE_SESSION_IMPL *session, const char *cfg[]);
extern int __ae_txn_named_snapshot_get(AE_SESSION_IMPL *session, AE_CONFIG_ITEM *nameval);
extern int __ae_txn_named_snapshot_config(AE_SESSION_IMPL *session, const char *cfg[], bool *has_create, bool *has_drops);
extern int __ae_txn_named_snapshot_destroy(AE_SESSION_IMPL *session);
extern int __ae_txn_recover(AE_SESSION_IMPL *session);
